// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "template_feature.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace pb {

void protobuf_ShutdownFile_template_5ffeature_2eproto() {
  delete KeyPoint::default_instance_;
  delete Image::default_instance_;
  delete SingleTemlate::default_instance_;
  delete SinglePersonTemplate::default_instance_;
  delete TemplateFile::default_instance_;
}

void protobuf_AddDesc_template_5ffeature_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  KeyPoint::default_instance_ = new KeyPoint();
  Image::default_instance_ = new Image();
  SingleTemlate::default_instance_ = new SingleTemlate();
  SinglePersonTemplate::default_instance_ = new SinglePersonTemplate();
  TemplateFile::default_instance_ = new TemplateFile();
  KeyPoint::default_instance_->InitAsDefaultInstance();
  Image::default_instance_->InitAsDefaultInstance();
  SingleTemlate::default_instance_->InitAsDefaultInstance();
  SinglePersonTemplate::default_instance_->InitAsDefaultInstance();
  TemplateFile::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_template_5ffeature_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_template_5ffeature_2eproto {
  StaticDescriptorInitializer_template_5ffeature_2eproto() {
    protobuf_AddDesc_template_5ffeature_2eproto();
  }
} static_descriptor_initializer_template_5ffeature_2eproto_;

bool FaceDirection_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int KeyPoint::kXFieldNumber;
const int KeyPoint::kYFieldNumber;
#endif  // !_MSC_VER

KeyPoint::KeyPoint()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void KeyPoint::InitAsDefaultInstance() {
}

KeyPoint::KeyPoint(const KeyPoint& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void KeyPoint::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KeyPoint::~KeyPoint() {
  SharedDtor();
}

void KeyPoint::SharedDtor() {
  if (this != default_instance_) {
  }
}

void KeyPoint::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const KeyPoint& KeyPoint::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_template_5ffeature_2eproto();  return *default_instance_;
}

KeyPoint* KeyPoint::default_instance_ = NULL;

KeyPoint* KeyPoint::New() const {
  return new KeyPoint;
}

void KeyPoint::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    y_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool KeyPoint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }
      
      // required float y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void KeyPoint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }
  
  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }
  
}

int KeyPoint::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float x = 1;
    if (has_x()) {
      total_size += 1 + 4;
    }
    
    // required float y = 2;
    if (has_y()) {
      total_size += 1 + 4;
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KeyPoint::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const KeyPoint*>(&from));
}

void KeyPoint::MergeFrom(const KeyPoint& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
  }
}

void KeyPoint::CopyFrom(const KeyPoint& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyPoint::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void KeyPoint::Swap(KeyPoint* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string KeyPoint::GetTypeName() const {
  return "pb.KeyPoint";
}


// ===================================================================

#ifndef _MSC_VER
const int Image::kDataFieldNumber;
const int Image::kFormatFieldNumber;
const int Image::kWidthFieldNumber;
const int Image::kHeightFieldNumber;
const int Image::kStrideFieldNumber;
#endif  // !_MSC_VER

Image::Image()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Image::InitAsDefaultInstance() {
}

Image::Image(const Image& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Image::SharedCtor() {
  _cached_size_ = 0;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  format_ = 0u;
  width_ = 0;
  height_ = 0;
  stride_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Image::~Image() {
  SharedDtor();
}

void Image::SharedDtor() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (this != default_instance_) {
  }
}

void Image::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Image& Image::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_template_5ffeature_2eproto();  return *default_instance_;
}

Image* Image::default_instance_ = NULL;

Image* Image::New() const {
  return new Image;
}

void Image::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::kEmptyString) {
        data_->clear();
      }
    }
    format_ = 0u;
    width_ = 0;
    height_ = 0;
    stride_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Image::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes data = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_format;
        break;
      }
      
      // required uint32 format = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_format:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &format_)));
          set_has_format();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_width;
        break;
      }
      
      // required int32 width = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_height;
        break;
      }
      
      // required int32 height = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_stride;
        break;
      }
      
      // required int32 stride = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_stride:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &stride_)));
          set_has_stride();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Image::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes data = 1;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->data(), output);
  }
  
  // required uint32 format = 2;
  if (has_format()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->format(), output);
  }
  
  // required int32 width = 3;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->width(), output);
  }
  
  // required int32 height = 4;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->height(), output);
  }
  
  // required int32 stride = 5;
  if (has_stride()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->stride(), output);
  }
  
}

int Image::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes data = 1;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }
    
    // required uint32 format = 2;
    if (has_format()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->format());
    }
    
    // required int32 width = 3;
    if (has_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->width());
    }
    
    // required int32 height = 4;
    if (has_height()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->height());
    }
    
    // required int32 stride = 5;
    if (has_stride()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->stride());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Image::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Image*>(&from));
}

void Image::MergeFrom(const Image& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_data()) {
      set_data(from.data());
    }
    if (from.has_format()) {
      set_format(from.format());
    }
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
    if (from.has_stride()) {
      set_stride(from.stride());
    }
  }
}

void Image::CopyFrom(const Image& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Image::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  
  return true;
}

void Image::Swap(Image* other) {
  if (other != this) {
    std::swap(data_, other->data_);
    std::swap(format_, other->format_);
    std::swap(width_, other->width_);
    std::swap(height_, other->height_);
    std::swap(stride_, other->stride_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Image::GetTypeName() const {
  return "pb.Image";
}


// ===================================================================

#ifndef _MSC_VER
const int SingleTemlate::kImageInfoFieldNumber;
const int SingleTemlate::kFeatureFieldNumber;
const int SingleTemlate::kPointsFieldNumber;
const int SingleTemlate::kDirectionFieldNumber;
#endif  // !_MSC_VER

SingleTemlate::SingleTemlate()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SingleTemlate::InitAsDefaultInstance() {
  imageinfo_ = const_cast< ::pb::Image*>(&::pb::Image::default_instance());
}

SingleTemlate::SingleTemlate(const SingleTemlate& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SingleTemlate::SharedCtor() {
  _cached_size_ = 0;
  imageinfo_ = NULL;
  feature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  direction_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SingleTemlate::~SingleTemlate() {
  SharedDtor();
}

void SingleTemlate::SharedDtor() {
  if (feature_ != &::google::protobuf::internal::kEmptyString) {
    delete feature_;
  }
  if (this != default_instance_) {
    delete imageinfo_;
  }
}

void SingleTemlate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SingleTemlate& SingleTemlate::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_template_5ffeature_2eproto();  return *default_instance_;
}

SingleTemlate* SingleTemlate::default_instance_ = NULL;

SingleTemlate* SingleTemlate::New() const {
  return new SingleTemlate;
}

void SingleTemlate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_imageinfo()) {
      if (imageinfo_ != NULL) imageinfo_->::pb::Image::Clear();
    }
    if (has_feature()) {
      if (feature_ != &::google::protobuf::internal::kEmptyString) {
        feature_->clear();
      }
    }
    direction_ = 0;
  }
  points_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SingleTemlate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .pb.Image imageInfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_imageinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_feature;
        break;
      }
      
      // required string feature = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_feature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_feature()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_points;
        break;
      }
      
      // repeated .pb.KeyPoint points = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_points:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_points()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_points;
        if (input->ExpectTag(32)) goto parse_direction;
        break;
      }
      
      // optional .pb.FaceDirection direction = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_direction:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (pb::FaceDirection_IsValid(value)) {
            set_direction(static_cast< pb::FaceDirection >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SingleTemlate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .pb.Image imageInfo = 1;
  if (has_imageinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->imageinfo(), output);
  }
  
  // required string feature = 2;
  if (has_feature()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->feature(), output);
  }
  
  // repeated .pb.KeyPoint points = 3;
  for (int i = 0; i < this->points_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->points(i), output);
  }
  
  // optional .pb.FaceDirection direction = 4;
  if (has_direction()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->direction(), output);
  }
  
}

int SingleTemlate::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .pb.Image imageInfo = 1;
    if (has_imageinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->imageinfo());
    }
    
    // required string feature = 2;
    if (has_feature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->feature());
    }
    
    // optional .pb.FaceDirection direction = 4;
    if (has_direction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->direction());
    }
    
  }
  // repeated .pb.KeyPoint points = 3;
  total_size += 1 * this->points_size();
  for (int i = 0; i < this->points_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->points(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SingleTemlate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SingleTemlate*>(&from));
}

void SingleTemlate::MergeFrom(const SingleTemlate& from) {
  GOOGLE_CHECK_NE(&from, this);
  points_.MergeFrom(from.points_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_imageinfo()) {
      mutable_imageinfo()->::pb::Image::MergeFrom(from.imageinfo());
    }
    if (from.has_feature()) {
      set_feature(from.feature());
    }
    if (from.has_direction()) {
      set_direction(from.direction());
    }
  }
}

void SingleTemlate::CopyFrom(const SingleTemlate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SingleTemlate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_imageinfo()) {
    if (!this->imageinfo().IsInitialized()) return false;
  }
  for (int i = 0; i < points_size(); i++) {
    if (!this->points(i).IsInitialized()) return false;
  }
  return true;
}

void SingleTemlate::Swap(SingleTemlate* other) {
  if (other != this) {
    std::swap(imageinfo_, other->imageinfo_);
    std::swap(feature_, other->feature_);
    points_.Swap(&other->points_);
    std::swap(direction_, other->direction_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SingleTemlate::GetTypeName() const {
  return "pb.SingleTemlate";
}


// ===================================================================

#ifndef _MSC_VER
const int SinglePersonTemplate::kIndexFieldNumber;
const int SinglePersonTemplate::kSingleTemlateFieldNumber;
#endif  // !_MSC_VER

SinglePersonTemplate::SinglePersonTemplate()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SinglePersonTemplate::InitAsDefaultInstance() {
}

SinglePersonTemplate::SinglePersonTemplate(const SinglePersonTemplate& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SinglePersonTemplate::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SinglePersonTemplate::~SinglePersonTemplate() {
  SharedDtor();
}

void SinglePersonTemplate::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SinglePersonTemplate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SinglePersonTemplate& SinglePersonTemplate::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_template_5ffeature_2eproto();  return *default_instance_;
}

SinglePersonTemplate* SinglePersonTemplate::default_instance_ = NULL;

SinglePersonTemplate* SinglePersonTemplate::New() const {
  return new SinglePersonTemplate;
}

void SinglePersonTemplate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    index_ = 0;
  }
  singletemlate_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SinglePersonTemplate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 index = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_singleTemlate;
        break;
      }
      
      // repeated .pb.SingleTemlate singleTemlate = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_singleTemlate:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_singletemlate()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_singleTemlate;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SinglePersonTemplate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->index(), output);
  }
  
  // repeated .pb.SingleTemlate singleTemlate = 2;
  for (int i = 0; i < this->singletemlate_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->singletemlate(i), output);
  }
  
}

int SinglePersonTemplate::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }
    
  }
  // repeated .pb.SingleTemlate singleTemlate = 2;
  total_size += 1 * this->singletemlate_size();
  for (int i = 0; i < this->singletemlate_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->singletemlate(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SinglePersonTemplate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SinglePersonTemplate*>(&from));
}

void SinglePersonTemplate::MergeFrom(const SinglePersonTemplate& from) {
  GOOGLE_CHECK_NE(&from, this);
  singletemlate_.MergeFrom(from.singletemlate_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
  }
}

void SinglePersonTemplate::CopyFrom(const SinglePersonTemplate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SinglePersonTemplate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  for (int i = 0; i < singletemlate_size(); i++) {
    if (!this->singletemlate(i).IsInitialized()) return false;
  }
  return true;
}

void SinglePersonTemplate::Swap(SinglePersonTemplate* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    singletemlate_.Swap(&other->singletemlate_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SinglePersonTemplate::GetTypeName() const {
  return "pb.SinglePersonTemplate";
}


// ===================================================================

const ::std::string TemplateFile::_default_versionstring_("1.0.0");
#ifndef _MSC_VER
const int TemplateFile::kVersionStringFieldNumber;
const int TemplateFile::kSinglePersonTemplateIndexFieldNumber;
const int TemplateFile::kModelVersionFieldNumber;
const int TemplateFile::kIdentifierFieldNumber;
const int TemplateFile::kSinglePersonTemplateFieldNumber;
#endif  // !_MSC_VER

TemplateFile::TemplateFile()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TemplateFile::InitAsDefaultInstance() {
}

TemplateFile::TemplateFile(const TemplateFile& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TemplateFile::SharedCtor() {
  _cached_size_ = 0;
  versionstring_ = const_cast< ::std::string*>(&_default_versionstring_);
  singlepersontemplateindex_ = 0;
  modelversion_ = 0;
  identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TemplateFile::~TemplateFile() {
  SharedDtor();
}

void TemplateFile::SharedDtor() {
  if (versionstring_ != &_default_versionstring_) {
    delete versionstring_;
  }
  if (identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete identifier_;
  }
  if (this != default_instance_) {
  }
}

void TemplateFile::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TemplateFile& TemplateFile::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_template_5ffeature_2eproto();  return *default_instance_;
}

TemplateFile* TemplateFile::default_instance_ = NULL;

TemplateFile* TemplateFile::New() const {
  return new TemplateFile;
}

void TemplateFile::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_versionstring()) {
      if (versionstring_ != &_default_versionstring_) {
        versionstring_->assign(_default_versionstring_);
      }
    }
    singlepersontemplateindex_ = 0;
    modelversion_ = 0;
    if (has_identifier()) {
      if (identifier_ != &::google::protobuf::internal::kEmptyString) {
        identifier_->clear();
      }
    }
  }
  singlepersontemplate_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TemplateFile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string versionString = 1 [default = "1.0.0"];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_versionstring()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_singlePersonTemplateIndex;
        break;
      }
      
      // required int32 singlePersonTemplateIndex = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_singlePersonTemplateIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &singlepersontemplateindex_)));
          set_has_singlepersontemplateindex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_modelVersion;
        break;
      }
      
      // required int32 modelVersion = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_modelVersion:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &modelversion_)));
          set_has_modelversion();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_identifier;
        break;
      }
      
      // required string identifier = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_identifier:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_identifier()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_singlePersonTemplate;
        break;
      }
      
      // repeated .pb.SinglePersonTemplate singlePersonTemplate = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_singlePersonTemplate:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_singlepersontemplate()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_singlePersonTemplate;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TemplateFile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string versionString = 1 [default = "1.0.0"];
  if (has_versionstring()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->versionstring(), output);
  }
  
  // required int32 singlePersonTemplateIndex = 2;
  if (has_singlepersontemplateindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->singlepersontemplateindex(), output);
  }
  
  // required int32 modelVersion = 3;
  if (has_modelversion()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->modelversion(), output);
  }
  
  // required string identifier = 4;
  if (has_identifier()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->identifier(), output);
  }
  
  // repeated .pb.SinglePersonTemplate singlePersonTemplate = 5;
  for (int i = 0; i < this->singlepersontemplate_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->singlepersontemplate(i), output);
  }
  
}

int TemplateFile::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string versionString = 1 [default = "1.0.0"];
    if (has_versionstring()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->versionstring());
    }
    
    // required int32 singlePersonTemplateIndex = 2;
    if (has_singlepersontemplateindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->singlepersontemplateindex());
    }
    
    // required int32 modelVersion = 3;
    if (has_modelversion()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->modelversion());
    }
    
    // required string identifier = 4;
    if (has_identifier()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->identifier());
    }
    
  }
  // repeated .pb.SinglePersonTemplate singlePersonTemplate = 5;
  total_size += 1 * this->singlepersontemplate_size();
  for (int i = 0; i < this->singlepersontemplate_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->singlepersontemplate(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TemplateFile::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TemplateFile*>(&from));
}

void TemplateFile::MergeFrom(const TemplateFile& from) {
  GOOGLE_CHECK_NE(&from, this);
  singlepersontemplate_.MergeFrom(from.singlepersontemplate_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_versionstring()) {
      set_versionstring(from.versionstring());
    }
    if (from.has_singlepersontemplateindex()) {
      set_singlepersontemplateindex(from.singlepersontemplateindex());
    }
    if (from.has_modelversion()) {
      set_modelversion(from.modelversion());
    }
    if (from.has_identifier()) {
      set_identifier(from.identifier());
    }
  }
}

void TemplateFile::CopyFrom(const TemplateFile& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TemplateFile::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  for (int i = 0; i < singlepersontemplate_size(); i++) {
    if (!this->singlepersontemplate(i).IsInitialized()) return false;
  }
  return true;
}

void TemplateFile::Swap(TemplateFile* other) {
  if (other != this) {
    std::swap(versionstring_, other->versionstring_);
    std::swap(singlepersontemplateindex_, other->singlepersontemplateindex_);
    std::swap(modelversion_, other->modelversion_);
    std::swap(identifier_, other->identifier_);
    singlepersontemplate_.Swap(&other->singlepersontemplate_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TemplateFile::GetTypeName() const {
  return "pb.TemplateFile";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

// @@protoc_insertion_point(global_scope)
