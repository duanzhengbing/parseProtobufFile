// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: template_feature.proto

#ifndef PROTOBUF_template_5ffeature_2eproto__INCLUDED
#define PROTOBUF_template_5ffeature_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_template_5ffeature_2eproto();
void protobuf_AssignDesc_template_5ffeature_2eproto();
void protobuf_ShutdownFile_template_5ffeature_2eproto();

class KeyPoint;
class Image;
class SingleTemlate;
class SinglePersonTemplate;
class TemplateFile;

enum FaceDirection {
  MIDDLE = 0,
  UP = 1,
  DOWN = 2,
  LEFT = 3,
  RIGHT = 4
};
bool FaceDirection_IsValid(int value);
const FaceDirection FaceDirection_MIN = MIDDLE;
const FaceDirection FaceDirection_MAX = RIGHT;
const int FaceDirection_ARRAYSIZE = FaceDirection_MAX + 1;

// ===================================================================

class KeyPoint : public ::google::protobuf::MessageLite {
 public:
  KeyPoint();
  virtual ~KeyPoint();
  
  KeyPoint(const KeyPoint& from);
  
  inline KeyPoint& operator=(const KeyPoint& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const KeyPoint& default_instance();
  
  void Swap(KeyPoint* other);
  
  // implements Message ----------------------------------------------
  
  KeyPoint* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const KeyPoint& from);
  void MergeFrom(const KeyPoint& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // @@protoc_insertion_point(class_scope:pb.KeyPoint)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  
  float x_;
  float y_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_template_5ffeature_2eproto();
  friend void protobuf_AssignDesc_template_5ffeature_2eproto();
  friend void protobuf_ShutdownFile_template_5ffeature_2eproto();
  
  void InitAsDefaultInstance();
  static KeyPoint* default_instance_;
};
// -------------------------------------------------------------------

class Image : public ::google::protobuf::MessageLite {
 public:
  Image();
  virtual ~Image();
  
  Image(const Image& from);
  
  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Image& default_instance();
  
  void Swap(Image* other);
  
  // implements Message ----------------------------------------------
  
  Image* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // required uint32 format = 2;
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 2;
  inline ::google::protobuf::uint32 format() const;
  inline void set_format(::google::protobuf::uint32 value);
  
  // required int32 width = 3;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 3;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);
  
  // required int32 height = 4;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 4;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);
  
  // required int32 stride = 5;
  inline bool has_stride() const;
  inline void clear_stride();
  static const int kStrideFieldNumber = 5;
  inline ::google::protobuf::int32 stride() const;
  inline void set_stride(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:pb.Image)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_format();
  inline void clear_has_format();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_stride();
  inline void clear_has_stride();
  
  ::std::string* data_;
  ::google::protobuf::uint32 format_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 stride_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_template_5ffeature_2eproto();
  friend void protobuf_AssignDesc_template_5ffeature_2eproto();
  friend void protobuf_ShutdownFile_template_5ffeature_2eproto();
  
  void InitAsDefaultInstance();
  static Image* default_instance_;
};
// -------------------------------------------------------------------

class SingleTemlate : public ::google::protobuf::MessageLite {
 public:
  SingleTemlate();
  virtual ~SingleTemlate();
  
  SingleTemlate(const SingleTemlate& from);
  
  inline SingleTemlate& operator=(const SingleTemlate& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const SingleTemlate& default_instance();
  
  void Swap(SingleTemlate* other);
  
  // implements Message ----------------------------------------------
  
  SingleTemlate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SingleTemlate& from);
  void MergeFrom(const SingleTemlate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .pb.Image imageInfo = 1;
  inline bool has_imageinfo() const;
  inline void clear_imageinfo();
  static const int kImageInfoFieldNumber = 1;
  inline const ::pb::Image& imageinfo() const;
  inline ::pb::Image* mutable_imageinfo();
  inline ::pb::Image* release_imageinfo();
  
  // required string feature = 2;
  inline bool has_feature() const;
  inline void clear_feature();
  static const int kFeatureFieldNumber = 2;
  inline const ::std::string& feature() const;
  inline void set_feature(const ::std::string& value);
  inline void set_feature(const char* value);
  inline void set_feature(const char* value, size_t size);
  inline ::std::string* mutable_feature();
  inline ::std::string* release_feature();
  
  // repeated .pb.KeyPoint points = 3;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 3;
  inline const ::pb::KeyPoint& points(int index) const;
  inline ::pb::KeyPoint* mutable_points(int index);
  inline ::pb::KeyPoint* add_points();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::KeyPoint >&
      points() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::KeyPoint >*
      mutable_points();
  
  // optional .pb.FaceDirection direction = 4;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 4;
  inline pb::FaceDirection direction() const;
  inline void set_direction(pb::FaceDirection value);
  
  // @@protoc_insertion_point(class_scope:pb.SingleTemlate)
 private:
  inline void set_has_imageinfo();
  inline void clear_has_imageinfo();
  inline void set_has_feature();
  inline void clear_has_feature();
  inline void set_has_direction();
  inline void clear_has_direction();
  
  ::pb::Image* imageinfo_;
  ::std::string* feature_;
  ::google::protobuf::RepeatedPtrField< ::pb::KeyPoint > points_;
  int direction_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_template_5ffeature_2eproto();
  friend void protobuf_AssignDesc_template_5ffeature_2eproto();
  friend void protobuf_ShutdownFile_template_5ffeature_2eproto();
  
  void InitAsDefaultInstance();
  static SingleTemlate* default_instance_;
};
// -------------------------------------------------------------------

class SinglePersonTemplate : public ::google::protobuf::MessageLite {
 public:
  SinglePersonTemplate();
  virtual ~SinglePersonTemplate();
  
  SinglePersonTemplate(const SinglePersonTemplate& from);
  
  inline SinglePersonTemplate& operator=(const SinglePersonTemplate& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const SinglePersonTemplate& default_instance();
  
  void Swap(SinglePersonTemplate* other);
  
  // implements Message ----------------------------------------------
  
  SinglePersonTemplate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SinglePersonTemplate& from);
  void MergeFrom(const SinglePersonTemplate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);
  
  // repeated .pb.SingleTemlate singleTemlate = 2;
  inline int singletemlate_size() const;
  inline void clear_singletemlate();
  static const int kSingleTemlateFieldNumber = 2;
  inline const ::pb::SingleTemlate& singletemlate(int index) const;
  inline ::pb::SingleTemlate* mutable_singletemlate(int index);
  inline ::pb::SingleTemlate* add_singletemlate();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::SingleTemlate >&
      singletemlate() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::SingleTemlate >*
      mutable_singletemlate();
  
  // @@protoc_insertion_point(class_scope:pb.SinglePersonTemplate)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  
  ::google::protobuf::RepeatedPtrField< ::pb::SingleTemlate > singletemlate_;
  ::google::protobuf::int32 index_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_template_5ffeature_2eproto();
  friend void protobuf_AssignDesc_template_5ffeature_2eproto();
  friend void protobuf_ShutdownFile_template_5ffeature_2eproto();
  
  void InitAsDefaultInstance();
  static SinglePersonTemplate* default_instance_;
};
// -------------------------------------------------------------------

class TemplateFile : public ::google::protobuf::MessageLite {
 public:
  TemplateFile();
  virtual ~TemplateFile();
  
  TemplateFile(const TemplateFile& from);
  
  inline TemplateFile& operator=(const TemplateFile& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const TemplateFile& default_instance();
  
  void Swap(TemplateFile* other);
  
  // implements Message ----------------------------------------------
  
  TemplateFile* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TemplateFile& from);
  void MergeFrom(const TemplateFile& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string versionString = 1 [default = "1.0.0"];
  inline bool has_versionstring() const;
  inline void clear_versionstring();
  static const int kVersionStringFieldNumber = 1;
  inline const ::std::string& versionstring() const;
  inline void set_versionstring(const ::std::string& value);
  inline void set_versionstring(const char* value);
  inline void set_versionstring(const char* value, size_t size);
  inline ::std::string* mutable_versionstring();
  inline ::std::string* release_versionstring();
  
  // required int32 singlePersonTemplateIndex = 2;
  inline bool has_singlepersontemplateindex() const;
  inline void clear_singlepersontemplateindex();
  static const int kSinglePersonTemplateIndexFieldNumber = 2;
  inline ::google::protobuf::int32 singlepersontemplateindex() const;
  inline void set_singlepersontemplateindex(::google::protobuf::int32 value);
  
  // required int32 modelVersion = 3;
  inline bool has_modelversion() const;
  inline void clear_modelversion();
  static const int kModelVersionFieldNumber = 3;
  inline ::google::protobuf::int32 modelversion() const;
  inline void set_modelversion(::google::protobuf::int32 value);
  
  // required string identifier = 4;
  inline bool has_identifier() const;
  inline void clear_identifier();
  static const int kIdentifierFieldNumber = 4;
  inline const ::std::string& identifier() const;
  inline void set_identifier(const ::std::string& value);
  inline void set_identifier(const char* value);
  inline void set_identifier(const char* value, size_t size);
  inline ::std::string* mutable_identifier();
  inline ::std::string* release_identifier();
  
  // repeated .pb.SinglePersonTemplate singlePersonTemplate = 5;
  inline int singlepersontemplate_size() const;
  inline void clear_singlepersontemplate();
  static const int kSinglePersonTemplateFieldNumber = 5;
  inline const ::pb::SinglePersonTemplate& singlepersontemplate(int index) const;
  inline ::pb::SinglePersonTemplate* mutable_singlepersontemplate(int index);
  inline ::pb::SinglePersonTemplate* add_singlepersontemplate();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::SinglePersonTemplate >&
      singlepersontemplate() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::SinglePersonTemplate >*
      mutable_singlepersontemplate();
  
  // @@protoc_insertion_point(class_scope:pb.TemplateFile)
 private:
  inline void set_has_versionstring();
  inline void clear_has_versionstring();
  inline void set_has_singlepersontemplateindex();
  inline void clear_has_singlepersontemplateindex();
  inline void set_has_modelversion();
  inline void clear_has_modelversion();
  inline void set_has_identifier();
  inline void clear_has_identifier();
  
  ::std::string* versionstring_;
  static const ::std::string _default_versionstring_;
  ::google::protobuf::int32 singlepersontemplateindex_;
  ::google::protobuf::int32 modelversion_;
  ::std::string* identifier_;
  ::google::protobuf::RepeatedPtrField< ::pb::SinglePersonTemplate > singlepersontemplate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_template_5ffeature_2eproto();
  friend void protobuf_AssignDesc_template_5ffeature_2eproto();
  friend void protobuf_ShutdownFile_template_5ffeature_2eproto();
  
  void InitAsDefaultInstance();
  static TemplateFile* default_instance_;
};
// ===================================================================


// ===================================================================

// KeyPoint

// required float x = 1;
inline bool KeyPoint::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyPoint::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyPoint::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyPoint::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float KeyPoint::x() const {
  return x_;
}
inline void KeyPoint::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool KeyPoint::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyPoint::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyPoint::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyPoint::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float KeyPoint::y() const {
  return y_;
}
inline void KeyPoint::set_y(float value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// Image

// required bytes data = 1;
inline bool Image::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Image::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Image::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Image::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& Image::data() const {
  return *data_;
}
inline void Image::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Image::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Image::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Image::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* Image::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 format = 2;
inline bool Image::has_format() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Image::set_has_format() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Image::clear_has_format() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Image::clear_format() {
  format_ = 0u;
  clear_has_format();
}
inline ::google::protobuf::uint32 Image::format() const {
  return format_;
}
inline void Image::set_format(::google::protobuf::uint32 value) {
  set_has_format();
  format_ = value;
}

// required int32 width = 3;
inline bool Image::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Image::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Image::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Image::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 Image::width() const {
  return width_;
}
inline void Image::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// required int32 height = 4;
inline bool Image::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Image::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Image::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Image::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 Image::height() const {
  return height_;
}
inline void Image::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// required int32 stride = 5;
inline bool Image::has_stride() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Image::set_has_stride() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Image::clear_has_stride() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Image::clear_stride() {
  stride_ = 0;
  clear_has_stride();
}
inline ::google::protobuf::int32 Image::stride() const {
  return stride_;
}
inline void Image::set_stride(::google::protobuf::int32 value) {
  set_has_stride();
  stride_ = value;
}

// -------------------------------------------------------------------

// SingleTemlate

// required .pb.Image imageInfo = 1;
inline bool SingleTemlate::has_imageinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SingleTemlate::set_has_imageinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SingleTemlate::clear_has_imageinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SingleTemlate::clear_imageinfo() {
  if (imageinfo_ != NULL) imageinfo_->::pb::Image::Clear();
  clear_has_imageinfo();
}
inline const ::pb::Image& SingleTemlate::imageinfo() const {
  return imageinfo_ != NULL ? *imageinfo_ : *default_instance_->imageinfo_;
}
inline ::pb::Image* SingleTemlate::mutable_imageinfo() {
  set_has_imageinfo();
  if (imageinfo_ == NULL) imageinfo_ = new ::pb::Image;
  return imageinfo_;
}
inline ::pb::Image* SingleTemlate::release_imageinfo() {
  clear_has_imageinfo();
  ::pb::Image* temp = imageinfo_;
  imageinfo_ = NULL;
  return temp;
}

// required string feature = 2;
inline bool SingleTemlate::has_feature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SingleTemlate::set_has_feature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SingleTemlate::clear_has_feature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SingleTemlate::clear_feature() {
  if (feature_ != &::google::protobuf::internal::kEmptyString) {
    feature_->clear();
  }
  clear_has_feature();
}
inline const ::std::string& SingleTemlate::feature() const {
  return *feature_;
}
inline void SingleTemlate::set_feature(const ::std::string& value) {
  set_has_feature();
  if (feature_ == &::google::protobuf::internal::kEmptyString) {
    feature_ = new ::std::string;
  }
  feature_->assign(value);
}
inline void SingleTemlate::set_feature(const char* value) {
  set_has_feature();
  if (feature_ == &::google::protobuf::internal::kEmptyString) {
    feature_ = new ::std::string;
  }
  feature_->assign(value);
}
inline void SingleTemlate::set_feature(const char* value, size_t size) {
  set_has_feature();
  if (feature_ == &::google::protobuf::internal::kEmptyString) {
    feature_ = new ::std::string;
  }
  feature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SingleTemlate::mutable_feature() {
  set_has_feature();
  if (feature_ == &::google::protobuf::internal::kEmptyString) {
    feature_ = new ::std::string;
  }
  return feature_;
}
inline ::std::string* SingleTemlate::release_feature() {
  clear_has_feature();
  if (feature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = feature_;
    feature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .pb.KeyPoint points = 3;
inline int SingleTemlate::points_size() const {
  return points_.size();
}
inline void SingleTemlate::clear_points() {
  points_.Clear();
}
inline const ::pb::KeyPoint& SingleTemlate::points(int index) const {
  return points_.Get(index);
}
inline ::pb::KeyPoint* SingleTemlate::mutable_points(int index) {
  return points_.Mutable(index);
}
inline ::pb::KeyPoint* SingleTemlate::add_points() {
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::KeyPoint >&
SingleTemlate::points() const {
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::KeyPoint >*
SingleTemlate::mutable_points() {
  return &points_;
}

// optional .pb.FaceDirection direction = 4;
inline bool SingleTemlate::has_direction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SingleTemlate::set_has_direction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SingleTemlate::clear_has_direction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SingleTemlate::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline pb::FaceDirection SingleTemlate::direction() const {
  return static_cast< pb::FaceDirection >(direction_);
}
inline void SingleTemlate::set_direction(pb::FaceDirection value) {
  GOOGLE_DCHECK(pb::FaceDirection_IsValid(value));
  set_has_direction();
  direction_ = value;
}

// -------------------------------------------------------------------

// SinglePersonTemplate

// required int32 index = 1;
inline bool SinglePersonTemplate::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SinglePersonTemplate::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SinglePersonTemplate::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SinglePersonTemplate::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 SinglePersonTemplate::index() const {
  return index_;
}
inline void SinglePersonTemplate::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// repeated .pb.SingleTemlate singleTemlate = 2;
inline int SinglePersonTemplate::singletemlate_size() const {
  return singletemlate_.size();
}
inline void SinglePersonTemplate::clear_singletemlate() {
  singletemlate_.Clear();
}
inline const ::pb::SingleTemlate& SinglePersonTemplate::singletemlate(int index) const {
  return singletemlate_.Get(index);
}
inline ::pb::SingleTemlate* SinglePersonTemplate::mutable_singletemlate(int index) {
  return singletemlate_.Mutable(index);
}
inline ::pb::SingleTemlate* SinglePersonTemplate::add_singletemlate() {
  return singletemlate_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::SingleTemlate >&
SinglePersonTemplate::singletemlate() const {
  return singletemlate_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::SingleTemlate >*
SinglePersonTemplate::mutable_singletemlate() {
  return &singletemlate_;
}

// -------------------------------------------------------------------

// TemplateFile

// required string versionString = 1 [default = "1.0.0"];
inline bool TemplateFile::has_versionstring() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TemplateFile::set_has_versionstring() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TemplateFile::clear_has_versionstring() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TemplateFile::clear_versionstring() {
  if (versionstring_ != &_default_versionstring_) {
    versionstring_->assign(_default_versionstring_);
  }
  clear_has_versionstring();
}
inline const ::std::string& TemplateFile::versionstring() const {
  return *versionstring_;
}
inline void TemplateFile::set_versionstring(const ::std::string& value) {
  set_has_versionstring();
  if (versionstring_ == &_default_versionstring_) {
    versionstring_ = new ::std::string;
  }
  versionstring_->assign(value);
}
inline void TemplateFile::set_versionstring(const char* value) {
  set_has_versionstring();
  if (versionstring_ == &_default_versionstring_) {
    versionstring_ = new ::std::string;
  }
  versionstring_->assign(value);
}
inline void TemplateFile::set_versionstring(const char* value, size_t size) {
  set_has_versionstring();
  if (versionstring_ == &_default_versionstring_) {
    versionstring_ = new ::std::string;
  }
  versionstring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TemplateFile::mutable_versionstring() {
  set_has_versionstring();
  if (versionstring_ == &_default_versionstring_) {
    versionstring_ = new ::std::string(_default_versionstring_);
  }
  return versionstring_;
}
inline ::std::string* TemplateFile::release_versionstring() {
  clear_has_versionstring();
  if (versionstring_ == &_default_versionstring_) {
    return NULL;
  } else {
    ::std::string* temp = versionstring_;
    versionstring_ = const_cast< ::std::string*>(&_default_versionstring_);
    return temp;
  }
}

// required int32 singlePersonTemplateIndex = 2;
inline bool TemplateFile::has_singlepersontemplateindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TemplateFile::set_has_singlepersontemplateindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TemplateFile::clear_has_singlepersontemplateindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TemplateFile::clear_singlepersontemplateindex() {
  singlepersontemplateindex_ = 0;
  clear_has_singlepersontemplateindex();
}
inline ::google::protobuf::int32 TemplateFile::singlepersontemplateindex() const {
  return singlepersontemplateindex_;
}
inline void TemplateFile::set_singlepersontemplateindex(::google::protobuf::int32 value) {
  set_has_singlepersontemplateindex();
  singlepersontemplateindex_ = value;
}

// required int32 modelVersion = 3;
inline bool TemplateFile::has_modelversion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TemplateFile::set_has_modelversion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TemplateFile::clear_has_modelversion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TemplateFile::clear_modelversion() {
  modelversion_ = 0;
  clear_has_modelversion();
}
inline ::google::protobuf::int32 TemplateFile::modelversion() const {
  return modelversion_;
}
inline void TemplateFile::set_modelversion(::google::protobuf::int32 value) {
  set_has_modelversion();
  modelversion_ = value;
}

// required string identifier = 4;
inline bool TemplateFile::has_identifier() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TemplateFile::set_has_identifier() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TemplateFile::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TemplateFile::clear_identifier() {
  if (identifier_ != &::google::protobuf::internal::kEmptyString) {
    identifier_->clear();
  }
  clear_has_identifier();
}
inline const ::std::string& TemplateFile::identifier() const {
  return *identifier_;
}
inline void TemplateFile::set_identifier(const ::std::string& value) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(value);
}
inline void TemplateFile::set_identifier(const char* value) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(value);
}
inline void TemplateFile::set_identifier(const char* value, size_t size) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TemplateFile::mutable_identifier() {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  return identifier_;
}
inline ::std::string* TemplateFile::release_identifier() {
  clear_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = identifier_;
    identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .pb.SinglePersonTemplate singlePersonTemplate = 5;
inline int TemplateFile::singlepersontemplate_size() const {
  return singlepersontemplate_.size();
}
inline void TemplateFile::clear_singlepersontemplate() {
  singlepersontemplate_.Clear();
}
inline const ::pb::SinglePersonTemplate& TemplateFile::singlepersontemplate(int index) const {
  return singlepersontemplate_.Get(index);
}
inline ::pb::SinglePersonTemplate* TemplateFile::mutable_singlepersontemplate(int index) {
  return singlepersontemplate_.Mutable(index);
}
inline ::pb::SinglePersonTemplate* TemplateFile::add_singlepersontemplate() {
  return singlepersontemplate_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::SinglePersonTemplate >&
TemplateFile::singlepersontemplate() const {
  return singlepersontemplate_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::SinglePersonTemplate >*
TemplateFile::mutable_singlepersontemplate() {
  return &singlepersontemplate_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_template_5ffeature_2eproto__INCLUDED
